#user  nobody
worker_processes  1;

#error_log  /var/log/nginx/error.log warn;

events {
	worker_connections  1024;
}

http {

	include	   mime.types;
	default_type  application/octet-stream;

	#gzip setup
	gzip on; 
	gzip_http_version 1.1; 
	gzip_vary on; 
	gzip_comp_level 6; 
	gzip_proxied any; 
	gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript text/x-js; 
	gzip_buffers 16 8k; 
	
	
	sendfile		on;	
	tcp_nopush on;
	tcp_nodelay on;
	keepalive_timeout 65;
	types_hash_max_size 2048;
	server_tokens off;

	#log formats
	log_format grafana '$time_iso8601 $remote_addr - $remote_user $proxy_host$request$cookie_grafanasess "$request" $status $body_bytes_sent $request_time' ;	
	log_format influx '$time_iso8601 $remote_addr - $remote_user "$scheme://$server_name/$uri" $status $body_bytes_sent $request_time' ;
	
	#proxy cache formats
	proxy_cache_path /tmp/grafana_cache levels=1:2 keys_zone=grafana_cache:25m max_size=500m inactive=5m use_temp_path=off;
	proxy_cache_path /tmp/influx_cache levels=1:2 keys_zone=influx_cache:25m max_size=50m inactive=15m use_temp_path=off;
	
	##################################Maps to detect Influx hardcoded traffic############################
	#check the referer to identify requests originated by Influx Web UI
	map $http_referer $proxyloc {	
		~*influx influx;
	}
	
	#Influx Web API end points
	map $request_uri $backend {	
		~*query influxdb;
		~*write influxdb;
		~*ping  influxdb;
	}
	
	#We will enable caching for only queries, not for regular UI pages of grafana
	map $request_uri $nonquery {	
		~*query 0;
		default 1;
	}
	#####################################################################################################
	
	
	
	server {
		listen	   %%interface%%:%%port%% default_server;
		#server_name  grafana.adystech.com;
		
	}
}